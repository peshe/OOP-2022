# Упражнение #1

## Структури

Mасивитe ни позволяваха да съхраняваме елементи от един и същи тип в последователна наредба. Например масив от цели числа, символи и тн. В реалния живот се налага да работим с елементи от различни типове. Тогава се намесват структурите. Структурите са типове данни дефинирани от потребителя, които ни позволяват да групираме елементи от различни типове и да ги съхраняваме.

```c++
struct <name of structure>
{
  <member definition>;  //  int arr[5];
  <member definition>;  //  int age;
  <member definition>;  //  double weight; 
        ...
  <member definition>;
  
}<one or more variables of <name> type>;

/*---------- Example ----------*/

struct Student
{
  char name[20];
  char faculty_number[5];
  unsigned int age;

};
 
```

### **Дефиниране на променливи от тип структура**
За структурата в паметта не се отделя памет. Паметта се отделя чак когато създадем обект от тип структура. Както при обикновените типове и тук дефинирането на променливи и константи от даден потребителски тип(структура) става чрез името на типа и името на променливата след това.

```c++
<
}name of structure> <variable_name>;

/*---------- Example ----------*/

Student student_one;

```

### **Разлика между обект и структура.**  
Структурата има за цел да обобщи и да дефинира как ще се държи даден обект от реалния свят. Чрез структурата създаваме различни видове обекти, които се обобщават в дадена структура. 

*Например* Ако имаме структурата Car променливите, които създаваме от тип Car са обекти.

Car volvo; Car golf; Car jigula са обекти. 

### **Достъп до елементите(членовете) на структурата**
Достъпът до, който и да е, елемент на структурата се осъществява чрез оператора(.). Като използваме следния синтаксис:

```c++
<name of object>.<member_name>;

/*---------- Example ----------*/

cout << student_one.name << endl;
```

### **Функции със структури**
За структурите е характерно, че променливите от тип структура могат да се инициализират със стойности на вече дефинирана променлива от същия тип. 

```c++

Student student_one;
Student student_two = student_two;

```
Но за да работим със структурите ефективно трябва да дефинираме и други функции, като например функция:
* за инициализиране на елементите на структурата
* за извеждане на елементите на структурата на екрана
* за променяне стойностите на елементите на структурата

## Enums

Изброеният тип (на английски: enumeration / enum - изброяване, списък) е конструкция, наподобяваща клас, в която обаче можем да декларираме само логически свързани константи.

Изброените типове могат да приемат стойности само измежду изброените в типа константи. Променлива от изброен тип може да има за стойност някоя измежду изброените в типа стойности (константи), но не може да има стойност null.

В повечето съвременни езици(обектно ориентирани) за програмиране се използва изборен тип, който се представя в паметта на компютъра, като подреден списък от константи. Ползването на константи вместо просто променливи, има положителен ефект върху чистотата и прилежността на програмния код, което е една от основните причини за въвеждането на изборен тип в програмирането

Декларацията на изброения тип в C и C++ става по подобен на предходните начин (опростена схема):

```c++
enum [идентификатор] [клас|структура] {елемeнти};
```
Идентификаторът е името на изброения тип. Класът и структурата са незадължителни спецификатори, а елементите са поредицата от елементи за дадения изборен тип.

```c++
enum Months{ January, February, April, May, June,
 June, July, August, September,
 October, November, December};
```

Всяка стойност от изброения тип става енумератор, т.е. има своя стойност, съответстваща на нейната позиция. По подразбиране стойностите започват от 0, но може да бъде зададена и ръчно, като всяка следваща се увеличава с единица:

```c++
enum Months{ January = 1, February, March April, May, June,
 June, July, August, September,
 October, November, December};
```

Така February ще е със стойност 2, March ще е с 3 и т.н.

Всяка стойност от изброения тип се третира като константа и трябва да бъде уникална за него.

Има малка разлика в декларирането в C и C++. В C ключовата дума enum е задължителна, докато в C++ тя може да бъде пропусната


## Битови полета

В езика C и C++ е възможно да се дефинират като елементи на структура и да се използват набори от битове;

Синтаксис:

```c++
struct mystruct {
  <тип> <име_променлива>:<ширина>
}
```
Където ширина е равна на броя битове, който искате променливата да ползва.

За всяко поле се отделят точно толкова битове, колкото са указани с ширината; достъпът до битовото поле става с помощта на указаното в него име; ако името е пропуснато, то описаните битове се заделят, но достъпът до тях е невъзможен; в стандарта на C и C++ няма специални ограничения относно типа на полето и размера, тези въпроси са решени отделно за всеки компилатор; битовите полета са машинно зависима конструкция; най-често използваните типове са unsigned int и int.
Размерът на всяко поле не може да надвишава броя на битовете, които се отделят за съответния тип.

При дефиниране на променлива от тип битово поле, заделената памет зависи от общата дължина на дефинираните полета; памет се заделя на порции, размера на които зависи от реализацията на компилатора – 1, 2, 4, 8 байта;

Примери:
```c++
struct S1
{
     // three-bit unsigned field, allowed values are 0...7
    int b : 3;
};
```

```c++
struct S2
{
    // define 3-bit-signed field
    char a : 3;

    // define multiple bit fields together
    unsigned char b:2, c:5, d:1;
};
```

![](char.png) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
