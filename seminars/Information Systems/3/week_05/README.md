# Упражнение 5

## Какво правихме предния път?
- какво представляват класовете
- дефиниция и употребра
- модификатори за достъп
- конструктори
- сетъри и гетъри

Продължаваме с обширната тема за класовете

## Const Const Const и Const 
Може би досега сте виждали асистентите да пишат някакви рандъм const-ове и може би не са дали най-подробното обясние или ако са дали бързо се забравя. Сега ще изясним всички const-ове, които може да наблъскаме в един метод.

```c++
class Person {
private:
  char* name;
  int age;
  .
  .
public:
  const char* getName() const;
  void setName(const char* other_name);
};
```

В тези два параграфа става въпрос за гетъра.
Досега трябва да сте разбрали какво прави един гетър, връща/дава достъп до конкретна член данна. Първият const преди char* само казва, че ще върнем константен символен низ този const ни защитава от това, че може да върнем някоя член данна и директно да я променим във въшния свят, което ще разбие тотално Енкапсулацията ни, буквално ще стане като директен достъп до нея. 

Последния const е едно обещание, което правим с нашия клас. Обещание, че във този метод ние НЯМА да променяме нашите член данни. Най - лесно се помни по следния начин: ако се очаква модифицираме някоя член данна в метода не го пишем, ако няма да се очаква да модифицираме член данните по - добре да го напишем. В гетъра ще имаме просто return this->name; което не модифицира нищо.

В този параграф става въпрос за сетъра.
В сетъра имаме пък един const по средата в някой аргумент. Това означава, че обещаваме, че вътре в метода ние НЯМА да променяме аргументите.

## Референции - &

```c++

class PrivateInformation {
  private:
    char* egn;
    char* bank_acc_username;
    char* bank_acc_password;
    .
    .
    .
}

class Person {
private:
  char* name;
  PrivateInformation private_info;
  .
  .
public:
  const PrivateInformation& getPrivateInformation() const;
  voi setPrivateInformation(const PrivateInformation& other_pr_info);
};
```

Когато връщаме или подаваме като аргумент, даден обект е хубаво да го връщаме и подаваме по референция (т.е да не правим копие), ОСВЕН ако нямаме нужда точно от копие на дадения обект (при връщане).


## Предефиниране на оператори
При класовете може да си позволим да предефинираме операторите ==, !=, = ,++ и т.н. С други думи казано, може да кажем какво влияние ще оказват тези оператори, когато ги прилагаме между обекти от класа, в който са предефинирани.

```c++
class Person {
private:
  char* name;
  int age;
  .
  .
public:
  const char* getName() const;
  void setName(const char* other_name);
  bool operator==(const Person& other_person) const {
    return strcmp(this->name,other_person.name) == 0 && this->age == other_person.age;
  };
  // тъй като вече сме предефинирали == може просто да върнем отрицанието му за != 
  bool operator!=(const Person& other_person) const {
    return !(*this == other_person); 
  }
};
```

## Голяма четворка 
### Когато заделяме динамична памет в нашия клас трябва да имаме голяма четворка, която се състои от дефолтен конструктор, конструктор за копиране, оператор= и деструктор. 
- Дефолтния конструктор се грижи при създаване на обект да се инициализират данните и да се заделя първоначална памет (ако имаме нужда от динамично заделяне)

- Конструктор за копиране ни позволява да инициализираме обект чрез друг обект.
Той също се грижи да правим deep copy вместо shallow copy, Shallow copy се прави когато нямаме конструктор за копиране от компилатора и в повечето случай не се заделя нова памет при копирането, а се пренасочват указателите, чрез което се получава споделена памет между два обекта, нещо което никога не искаме. Deep copy заделя НОВА памет за нашите член данни и указателите сочат към точно тази памет.

- Оператор за присвояване = също ни подсигурява, че ще правим Deep copy при присвояването, т.е като присвоим данните от един обект на нашия, няма да получим споделена памет. (Оператора = може да се ползва винаги в живота на един обект, докато конструктора за копиране, тъй каот е конструктор се ползва точно веднъж, когато инициализираме обекта)

- Деструктора се грижи за изчистване на заделената памет на обекта. Ако нямаме деструктор, а имаме заделяне на динамична памет ще получим Memory Leak. 

## Имплементация на голяма четворка
``` c++
class Player {
private:
	char* name;
	size_t age;
	size_t games_played;
	size_t wins;
	double win_chance;
	size_t current_points;
  // пишем си тук методи copy и erase, за да избегнем използване на един и същ код на няколко места.
	void copy(const Player& other) {
    	this->name = new char[strlen(other.name) + 1];
	    strcpy_s(this->name, strlen(other.name) + 1, other.name);

	    this->age = other.age;
	    this->wins = other.wins;
	    this->games_played = other.games_played;
	    this->win_chance = other.win_chance;
	    this->current_points = other.current_points;
  };
	void erase() {
      delete[] this->name; // тук трием само динамично заделената памет
  };

public:
    Player() {
      // за името заделяме 1 клетка за терминиращата нула, с други думи при инициализиция без данни ще имаме играч с име "".
        this->name = new char[1]; 
	    this->name[0] = '\0';

	    this->age = 18;
  	    this->games_played = 0;
	    this->wins = 0;
	    this->win_chance = 0;
	    this->current_points = 0;
    }
    Player(const Player& other) {
      this->copy(other);
    }
    Player& operator=(const Player& other) {
      // ако се опитаме да присвоим данни от един обект на друг, а те са един и същи обект ще получим грешка без тази проверка.
      if(this != &other) { // проверка дали указателите сочат към различни места
        this->erase(); // трябва да изтрием предишната памет
        this->copy(other); // копираме новите данни на чисто
      }
      return *this;
    }
    ~Player() {
      this->erase();
    }
};
```

## Как да ползваме .h и .cpp файлове

Header file (.h) - в него пишем синтаксиса `ifndef,define,endif`. В него импортваме всички библиотеки, които искаме да бъдат ползвани за имплементацията на методите в .cpp файла.
```c++
// player.h

#ifndef PLAYER_H
#define PLAYER_H

#include <cstring>
#include ...
#include ...

class Player {
  void method1();
  void method2();
  void method3();
  ...
  void methodN();
};

#endif
```

Cpp file (.cpp) - имплементация на методите

```c++
// player.cpp
#include "player.h"

void Player::method1() {

}

void Player::method2() {
  
}

void Player::method3() {
  
}
```

Накрая в main.cpp импортваме **само cpp файла!** 
P.S Това е така защото ползваме ifndef - endif при дефиниране на header и той изисква импорт на .cpp файла в main.

```c++
#include "player.cpp"
```