# Упражнение 11

## Какво правихме предния път?
- ООП принципи (преговор)
- наследяване - идея и основни концепции
- упражнение - задачи върху наследяване

## Множествено наследяване

До сега разгледахме една дребна част от голямата картинка, свързана с наследяването. Вече знаем какво представлява и какви са му основните концепции (**преговор тук**), затова нека вникнем малко по-надълбоко.

Ще използваме думите:
- производен клас - за "наследниците"
- основен клас - за "бащата"

Наследяването (или по-скоро класовете, които имплменетирахме при наследяване) до сега използваше отношението ```1 основен -> n производни``` или с други думи разгледахме примери, в които има един основен клас и всички останали класове наследяват от него. Пример:

```c++
class Animal {

};

class Dog : public Animal {}
class Rabbit : public Animal {}
class Cat : public Animal {}
```

Какво обаче ще се случи, ако искаме да обърнем отношението по някакъв начин? Например един човек от ФМИ е възможно да бъде както **асистент** така и **студент** заедно с това. Ако трябва да преведм това на ООП език ще получим следното:

```c++
class Assistant {};

class Student {};

class Person : public Assistant, public Student {
    // множествено наследяване
}
```

Акцентът тук пада върху класа `Person`, който хем наследява от Assistant, хем от Student. Това е пример за **множествено наследяване**, което може да дефинираме по следния начин:

Множествено наследяване имаме тогава, когато един производен клас има повече от един основен клас, като производния клас комбинира характеристиките и поведението на **всиките си основни класове**.

Още един пример:

```c++
class Bot : public Player, public AI { ... };
```

### Конструктори и деструктори

- конструкторите на производния клас трябва да указват как се
конструират всяка една от наследените части
- ако за някой от основните класове не е указан кой конструктор да
се извика, тогава се извика този по подразбиране

    Пример:
```c++
    Bot::Bot(char const* _name, int _pts, char const* _algo,
            double _threshold, int _difficulty)
    : Player(_name, _pts), AI(_algo, _threshold),
    difficulty(_difficulty)
```

Деструкторите на основните класове се викат автоматично, без да
правим каквото и да било. 

**РЕД НА ИЗПЪЛНЯВАНЕ**

Конструкторите се викат в реда, в който наследяваме от класа, докато деструкторите се викат в обратния на този ред. С други думи, първо минават основните класове, от които се наследява, а чак накрая производния клас.

### Предефинирани функции

Предефинираните функции могат да извикат съответна функция във
всеки един от основните класове.

```c++
void Bot::print() const {
    Player::print();
    AI::print();
    cout << "Ниво на трудност: " << difficulty << endl;
}
```

### Голяма четворка

- системно генерираните методи от голямата четворка правят това,
което трябва
- конструкторът **по подразбиране**, за **копиране** и **оператор=** на производния клас извиква
съответните такива на основните класове
- винаги редът е същият като реда на наследяване

## Диамантеният проблем

Така нареченият "Диамантен проблем", се случва когато два основни класа наследяват от един общ клас някакви стойности. Когато от четвърти клас наследим тези два основни класа получаваме повторения/конфилкт на данните от основния. С примерите ще стане по-ясно:

Проблемът получава името си от формата, която образуват класовете, представени графично:

![](diamont.png) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

Представяме проблемът и като код по следния начин: 

```c++
#include<iostream>
using namespace std;
class Person {
public:
    Person(int x)  { cout << "Person::Person(int ) called" << endl;   }
};
  
class Faculty : public Person {
public:
    Faculty(int x):Person(x)   {
       cout<<"Faculty::Faculty(int ) called"<< endl;
    }
};
  
class Student : public Person {
public:
    Student(int x):Person(x) {
        cout<<"Student::Student(int ) called"<< endl;
    }
};
  
class TA : public Faculty, public Student  {
public:
    TA(int x):Student(x), Faculty(x)   {
        cout<<"TA::TA(int ) called"<< endl;
    }
};
  
int main()  {
    TA ta1(30);
}
```

След изпълнение на програмата и внимателно проследяване на кода разбира се, става ясно, обектът `ta1(30)` има две копия на **всички член-данни и методи** дефинирани в `Person`. Ние програмистите не харесваме повторенията/копията. Как тогава да решим този проблем?

## Виртуални базови класове

Виртуално наследяване е C ++ техника, която осигурява **само едно копие** на базов клас.
Един клас не може да е виртуален сам по себе си, той може да
бъде наследен виртуално, т.е. да е виртуален основен клас. Всеки клас може да бъде наследен както нормално, така и виртуално.

**Транзитивност** - Ако класът B виртуално наследява A и C наследява (невиртуално)
B, то C автоматично виртуално наследява A.

ВАЖНО:
Виртуалността на основните класове се разпространява
автоматично по йерархията.
Затова всеки клас, трябва да се “грижи” за всичките си виртуални
основни класове, вместо да разчита за тази грижа на своите
директни родители.

Ако допълним `virtual` наследяване в горния пример, ще получим:

```c++
class Faculty : virtual public Person {
public:
    Faculty(int x):Person(x)   {
       cout<<"Faculty::Faculty(int ) called"<< endl;
    }
};
  
class Student : virtual public Person {
public:
    Student(int x):Person(x) {
        cout<<"Student::Student(int ) called"<< endl;
    }
};
```

Тук ще срещнем няколко проблема - първо, кластът `Person` НЯМА default конструктор => ще полчуим компилационна грешка поради причините изброени над примера.

Създаваме си default конструктор в базовия клас, който ще се извиква **винаги, дори когато на двата родителски класа се извиква експлицитно конструкторите с параметър.** 

За да извикваме конструктора с параметри на базовия клас, трябва ние да се "погрижим" за това в конструктора на `TA(int x)`


## public, private, protected наследяване

Наследяващият клас има достъп до всички член данни и методи на базовия клас, които НЕ са private, т.е ако дадени член данни или методи не трябва да бъдат достъпвани от наследените класове , се дефинират като private.
Когато данните на даден клас (член данни или методи) са дефинирани като protected, те нe са видими извън класа, но са видими и достъпни от класовете които го наследяват.


|Access|public|protected|private|
| :---: | :---: | :---: | :---: |
|Same class|yes|| yes |yes|
|Derived classes|yes|yes|no|
|Outside classes|yes|no|no|




Типът на наследяване се определя от спецификатора на достъп, в derivation list-a. Наследяването може да бъде : **private**, **protected** или **public**.
При използване на различен тип наследяване се прилагат следните правила:

- (public inheritance) –  public данните на базовия клас стават  public данни на наследяващия клас, а защитените данни на базовия клас стават защитени данни на производния клас. Частните членове на базовия клас НИКОГА не са достъпни директно от производен клас, но могат да бъдат достъпни чрез извиквания към публичните и защитени членове на базовия клас.

- (protected inheritance) – public и private данните на базовия клас стават protected данни в наследения клас.

- (private inheritance) – public и private данните на базовия клас стават private членове на производния клас.

