# Week 05
## Шаблони на функции и класове - [templates](http://www.cplusplus.com/doc/oldtutorial/templates/)
### Шаблони на функции
Шаблоните на функции са специални функции, които могат да работят с много различни типове. Това ни позволява да създадем шаблон за функция, чиято функционалност може да бъде адаптирана към повече от един тип или клас данни, без да се повтаря код за всеки отделен тип.

В C ++ това може да се постигне, като се използват **параметри на шаблона**. Това е специален вид параметър, който може да се използва за предаване на тип като аргумент: точно както обикновените параметри на функцията могат да се използват за подаване на стойности към дадена функция, параметрите на шаблона позволяват да се подават типове на функции.

Форматът за деклариране на шаблони на функции с **типови параметри** е:
```c++
template <class identifier> function_declaration;
template <typename identifier> function_declaration;
```
#### NB! И двата прототипа имат точно същото значение и се държат по същия начин.
#### Пример:
```c++
template <typename T>   // T e параметър на шаблона - това е типа, който по време на дефиницията на финкцията не искаме да посочваме
T max_of_two (T a, T b) {
    return (a > b? a : b);
}
```
Когато искам е да извикаме функцията за определен от нас тип, тогава:
```c++
int main()
{
    int first = 5, second = 12;
    
    cout << max_of_two <int> (first, second); // посочваме типа при извикването на функцията

    return 0;
}
```
Какво се случва зад колисите: Когато компилаторът срещне това извикване на шаблона, той използва шаблона, за да генерира автоматично функция, заменяща всяко срещане на типа T с типа, подаден като параметър (int в този случай), и след това я извиква. Този процес се изпълнява автоматично от компилатора и е невидим за програмиста.
#### Можем да добавяме няколко параметъра на шаблона => няколко различни типа
```c++
template <typename T, typename S>
void print_pair(T a, S b) {
	cout << a << " and type is: " << typeid(a).name() << endl;
	cout << b << " and type is: " << typeid(b).name() << endl;
}
```

### Шаблони на класове
Също така имаме възможност да пишем шаблони на класове, така че класът да има членове, които използват параметрите на шаблона като типове за тях.
#### Пример:
```c++
template <typename T>
class MyPair {
	T first;
	T second;
public:
	MyPair(T fst, T snd)
	{
		first = fst;
		second = snd;
	}
	void print() const
	{
		cout << "(" << first << ", " << second << ")\n";
	}
	T get_max();
};

// Aко не искаме да са inline

template<typename T>
T MyPair<T>::get_max() // <T> показва че Т-то, с което функцията работи и Т-то на класа са едни и същи
{
	return (first > second ? first : second);
}
```

#### Спецификация на шаблон - Ако искаме да дефинираме различна реализация на шаблон за конкретен тип, можем да дефинираме специализация на този шаблон за дадения тип.
Когато създадем обект от шаблона с даден тип, компилатора първо проверява всички спецификации на шаблона, ако няма съвпадение на типовете, се генерера клас с дадения тип, в противен случай се използва спецификацията.
```c++
template <>
class MyPair <char>{
...
};
```
#### Може да се задават параметри по подразбиране на шаблона:
```c++
template <typename T=char> 
class MyPair {..};
```

От гледна точка на езика шаблоните не са нормални функции или класове. Те се компилират при поискване, което означава, че кодът на шаблонна функция не се компилира, докато не се наложи инстанция с конкретни типове. В този момент, когато се изисква инстанция, компилаторът генерира функцията, специално за тези аргументи на шаблона(типове).

#### Разделяне на интерфейс и реализация
Когато проектите ви нарастват, обикновено кодът на програмата се разделя в различни файлове. В тези случаи интерфейсът и реализацията обикновено са разделени в различни файлове. Интерфейсът - се слага във файл с разширение .h, а реализацията на отделните методи се слага във файл със разширение .срр.

**Тъй като шаблоните се компилират при необходимост, това налага ограничения за проекти с множество файлове: реализацията (дефиницията) на даден клас или функция на шаблона трябва да бъде в същия файл като неговата декларация(интерфейс). Това означава, че не можем да отделим интерфейса в отделен заглавен файл и че трябва да включим и интерфейса и реализацията във всеки файл, който използва шаблона.**